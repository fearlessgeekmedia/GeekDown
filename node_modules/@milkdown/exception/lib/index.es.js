var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["docTypeError"] = "docTypeError";
  ErrorCode2["contextNotFound"] = "contextNotFound";
  ErrorCode2["timerNotFound"] = "timerNotFound";
  ErrorCode2["ctxCallOutOfScope"] = "ctxCallOutOfScope";
  ErrorCode2["createNodeInParserFail"] = "createNodeInParserFail";
  ErrorCode2["stackOverFlow"] = "stackOverFlow";
  ErrorCode2["parserMatchError"] = "parserMatchError";
  ErrorCode2["serializerMatchError"] = "serializerMatchError";
  ErrorCode2["getAtomFromSchemaFail"] = "getAtomFromSchemaFail";
  ErrorCode2["expectDomTypeError"] = "expectDomTypeError";
  ErrorCode2["callCommandBeforeEditorView"] = "callCommandBeforeEditorView";
  ErrorCode2["missingRootElement"] = "missingRootElement";
  ErrorCode2["missingNodeInSchema"] = "missingNodeInSchema";
  ErrorCode2["missingMarkInSchema"] = "missingMarkInSchema";
  ErrorCode2["ctxNotBind"] = "ctxNotBind";
  ErrorCode2["missingYjsDoc"] = "missingYjsDoc";
  return ErrorCode2;
})(ErrorCode || {});
class MilkdownError extends Error {
  constructor(code, message) {
    super(message);
    this.name = "MilkdownError";
    this.code = code;
  }
}
const functionReplacer = (_, value) => typeof value === "function" ? "[Function]" : value;
const stringify = (x) => JSON.stringify(x, functionReplacer);
function docTypeError(type) {
  return new MilkdownError(
    ErrorCode.docTypeError,
    `Doc type error, unsupported type: ${stringify(type)}`
  );
}
function contextNotFound(name) {
  return new MilkdownError(
    ErrorCode.contextNotFound,
    `Context "${name}" not found, do you forget to inject it?`
  );
}
function timerNotFound(name) {
  return new MilkdownError(
    ErrorCode.timerNotFound,
    `Timer "${name}" not found, do you forget to record it?`
  );
}
function ctxCallOutOfScope() {
  return new MilkdownError(
    ErrorCode.ctxCallOutOfScope,
    "Should not call a context out of the plugin."
  );
}
function createNodeInParserFail(...args) {
  const message = args.reduce((msg, arg) => {
    if (!arg) return msg;
    const serialize = (x) => {
      if (Array.isArray(x))
        return x.map((y) => serialize(y)).join(", ");
      if (x.toJSON)
        return stringify(
          x.toJSON()
        );
      if (x.spec)
        return stringify(x.spec);
      return x.toString();
    };
    return `${msg}, ${serialize(arg)}`;
  }, "Create prosemirror node from remark failed in parser");
  return new MilkdownError(ErrorCode.createNodeInParserFail, message);
}
function stackOverFlow() {
  return new MilkdownError(
    ErrorCode.stackOverFlow,
    "Stack over flow, cannot pop on an empty stack."
  );
}
function parserMatchError(node) {
  return new MilkdownError(
    ErrorCode.parserMatchError,
    `Cannot match target parser for node: ${stringify(node)}.`
  );
}
function serializerMatchError(node) {
  return new MilkdownError(
    ErrorCode.serializerMatchError,
    `Cannot match target serializer for node: ${stringify(node)}.`
  );
}
function getAtomFromSchemaFail(type, name) {
  return new MilkdownError(
    ErrorCode.getAtomFromSchemaFail,
    `Cannot get ${type}: ${name} from schema.`
  );
}
function expectDomTypeError(node) {
  return new MilkdownError(
    ErrorCode.expectDomTypeError,
    `Expect to be a dom, but get: ${stringify(node)}.`
  );
}
function callCommandBeforeEditorView() {
  return new MilkdownError(
    ErrorCode.callCommandBeforeEditorView,
    "You're trying to call a command before editor view initialized, make sure to get commandManager from ctx after editor view has been initialized"
  );
}
function missingRootElement() {
  return new MilkdownError(
    ErrorCode.missingRootElement,
    "Missing root element, milkdown cannot find root element of the editor."
  );
}
function missingNodeInSchema(name) {
  return new MilkdownError(
    ErrorCode.missingNodeInSchema,
    `Missing node in schema, milkdown cannot find "${name}" in schema.`
  );
}
function missingMarkInSchema(name) {
  return new MilkdownError(
    ErrorCode.missingMarkInSchema,
    `Missing mark in schema, milkdown cannot find "${name}" in schema.`
  );
}
function ctxNotBind() {
  return new MilkdownError(
    ErrorCode.ctxNotBind,
    "Context not bind, please make sure the plugin has been initialized."
  );
}
function missingYjsDoc() {
  return new MilkdownError(
    ErrorCode.missingYjsDoc,
    "Missing yjs doc, please make sure you have bind one."
  );
}
export {
  callCommandBeforeEditorView,
  contextNotFound,
  createNodeInParserFail,
  ctxCallOutOfScope,
  ctxNotBind,
  docTypeError,
  expectDomTypeError,
  getAtomFromSchemaFail,
  missingMarkInSchema,
  missingNodeInSchema,
  missingRootElement,
  missingYjsDoc,
  parserMatchError,
  serializerMatchError,
  stackOverFlow,
  timerNotFound
};
//# sourceMappingURL=index.es.js.map
