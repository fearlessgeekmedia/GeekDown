import {
  imageBlockSchema
} from "./chunk-KTGASOBN.js";
import "./chunk-2LSPA27C.js";
import {
  defIfNotExists,
  isInCodeBlock,
  isInList
} from "./chunk-NHCJLS3Q.js";
import {
  require_lodash as require_lodash2
} from "./chunk-CPITEZUQ.js";
import {
  computePosition,
  flip,
  offset
} from "./chunk-RLNND5KI.js";
import {
  bulletListIcon,
  c,
  codeIcon,
  dividerIcon,
  functionsIcon,
  h1Icon,
  h2Icon,
  h3Icon,
  h4Icon,
  h5Icon,
  h6Icon,
  html,
  imageIcon,
  menuIcon,
  orderedListIcon,
  plusIcon,
  quoteIcon,
  tableIcon,
  textIcon,
  todoListIcon,
  useCallback,
  useEffect,
  useHost,
  useMemo,
  useRef,
  useState
} from "./chunk-QO2MOLLE.js";
import {
  CrepeFeature,
  FeaturesCtx
} from "./chunk-FH25A5EA.js";
import {
  require_lodash
} from "./chunk-UNWTUWLU.js";
import "./chunk-CX5HPSVS.js";
import {
  createTable
} from "./chunk-PGGLTGNE.js";
import "./chunk-PSFXF772.js";
import {
  blockquoteSchema,
  bulletListSchema,
  codeBlockSchema,
  headingSchema,
  hrSchema,
  listItemSchema,
  orderedListSchema,
  paragraphSchema
} from "./chunk-FYJHHHFW.js";
import {
  $ctx,
  $prose,
  DOMSerializer,
  NodeSelection,
  Plugin,
  PluginKey,
  TextSelection,
  browser,
  editorViewCtx,
  findParent,
  findParentNode,
  findWrapping,
  posToDOMRect
} from "./chunk-SFBFV7Z3.js";
import "./chunk-VBO2Q2KC.js";
import {
  __toESM
} from "./chunk-NNPG3NYD.js";

// ../node_modules/@milkdown/plugin-block/lib/index.es.js
var import_lodash = __toESM(require_lodash2());
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _ctx;
var _createSelection;
var _activeSelection;
var _active;
var _activeDOMRect;
var _dragging;
var _BlockService_instances;
var filterNodes_get;
var view_get;
var _notify;
var _hide;
var _show;
var _handleMouseDown;
var _handleMouseUp;
var _handleDragStart;
var _mousemoveCallback;
var _dragEnd;
var _element;
var _ctx2;
var _service;
var _activeNode;
var _root;
var _initialized;
var _middleware;
var _floatingUIOptions;
var _getOffset;
var _getPosition;
var _getPlacement;
var _BlockProvider_instances;
var init_fn;
function withMeta(plugin, meta) {
  Object.assign(plugin, {
    meta: {
      package: "@milkdown/plugin-block",
      ...meta
    }
  });
  return plugin;
}
var defaultNodeFilter = (pos) => {
  const table = findParent((node) => node.type.name === "table")(pos);
  if (table)
    return false;
  return true;
};
var blockConfig = $ctx(
  { filterNodes: defaultNodeFilter },
  "blockConfig"
);
withMeta(blockConfig, {
  displayName: "Ctx<blockConfig>"
});
function selectRootNodeByDom(view, coords, filterNodes) {
  var _a;
  const root = view.dom.parentElement;
  if (!root)
    return null;
  try {
    const pos = (_a = view.posAtCoords({
      left: coords.x,
      top: coords.y
    })) == null ? void 0 : _a.inside;
    if (pos == null || pos < 0)
      return null;
    let $pos = view.state.doc.resolve(pos);
    let node = view.state.doc.nodeAt(pos);
    let element = view.nodeDOM(pos);
    const filter = (needLookup) => {
      const checkDepth = $pos.depth >= 1 && $pos.index($pos.depth) === 0;
      const shouldLookUp = needLookup || checkDepth;
      if (!shouldLookUp)
        return;
      const ancestorPos = $pos.before($pos.depth);
      node = view.state.doc.nodeAt(ancestorPos);
      element = view.nodeDOM(ancestorPos);
      $pos = view.state.doc.resolve(ancestorPos);
      if (!filterNodes($pos, node))
        filter(true);
    };
    const filterResult = filterNodes($pos, node);
    filter(!filterResult);
    if (!element || !node)
      return null;
    return { node, $pos, el: element };
  } catch {
    return null;
  }
}
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
function serializeForClipboard(view, slice) {
  const context = [];
  let { openStart, openEnd, content } = slice;
  while (openStart > 1 && openEnd > 1 && content.childCount === 1 && content.firstChild.childCount === 1) {
    openStart -= 1;
    openEnd -= 1;
    const node = content.firstChild;
    context.push(
      node.type.name,
      node.attrs !== node.type.defaultAttrs ? node.attrs : null
    );
    content = node.content;
  }
  const serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  const doc = detachedDoc();
  const wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, { document: doc }));
  let firstChild = wrap.firstChild;
  let needsWrap;
  let wrappers = 0;
  while (firstChild && firstChild.nodeType === 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      const wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild)
        wrapper.appendChild(wrap.firstChild);
      wrap.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType === 1) {
    firstChild.setAttribute(
      "data-pm-slice",
      `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`
    );
  }
  const text = view.someProp("clipboardTextSerializer", (f) => f(slice, view)) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return { dom: wrap, text };
}
var brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
var buffer = 20;
var BlockService = class {
  constructor() {
    __privateAdd(this, _BlockService_instances);
    __privateAdd(this, _ctx);
    __privateAdd(this, _createSelection);
    __privateAdd(this, _activeSelection);
    __privateAdd(this, _active);
    __privateAdd(this, _activeDOMRect);
    __privateAdd(this, _dragging);
    __privateAdd(this, _notify);
    __privateAdd(this, _hide);
    __privateAdd(this, _show);
    __privateAdd(this, _handleMouseDown);
    __privateAdd(this, _handleMouseUp);
    __privateAdd(this, _handleDragStart);
    __privateAdd(this, _mousemoveCallback);
    __privateAdd(this, _dragEnd);
    __privateSet(this, _createSelection, () => {
      if (!__privateGet(this, _active))
        return null;
      const result = __privateGet(this, _active);
      const view = __privateGet(this, _BlockService_instances, view_get);
      if (view && NodeSelection.isSelectable(result.node)) {
        const nodeSelection = NodeSelection.create(
          view.state.doc,
          result.$pos.pos
        );
        view.dispatch(view.state.tr.setSelection(nodeSelection));
        view.focus();
        __privateSet(this, _activeSelection, nodeSelection);
        return nodeSelection;
      }
      return null;
    });
    __privateSet(this, _activeSelection, null);
    __privateSet(this, _active, null);
    __privateSet(this, _activeDOMRect, void 0);
    __privateSet(this, _dragging, false);
    __privateSet(this, _hide, () => {
      var _a;
      (_a = __privateGet(this, _notify)) == null ? void 0 : _a.call(this, { type: "hide" });
      __privateSet(this, _active, null);
    });
    __privateSet(this, _show, (active) => {
      var _a;
      __privateSet(this, _active, active);
      (_a = __privateGet(this, _notify)) == null ? void 0 : _a.call(this, { type: "show", active });
    });
    this.bind = (ctx, notify) => {
      __privateSet(this, _ctx, ctx);
      __privateSet(this, _notify, notify);
    };
    this.addEvent = (dom) => {
      dom.addEventListener("mousedown", __privateGet(this, _handleMouseDown));
      dom.addEventListener("mouseup", __privateGet(this, _handleMouseUp));
      dom.addEventListener("dragstart", __privateGet(this, _handleDragStart));
    };
    this.removeEvent = (dom) => {
      dom.removeEventListener("mousedown", __privateGet(this, _handleMouseDown));
      dom.removeEventListener("mouseup", __privateGet(this, _handleMouseUp));
      dom.removeEventListener("dragstart", __privateGet(this, _handleDragStart));
    };
    this.unBind = () => {
      __privateSet(this, _notify, void 0);
    };
    __privateSet(this, _handleMouseDown, () => {
      var _a;
      __privateSet(this, _activeDOMRect, (_a = __privateGet(this, _active)) == null ? void 0 : _a.el.getBoundingClientRect());
      __privateGet(this, _createSelection).call(this);
    });
    __privateSet(this, _handleMouseUp, () => {
      if (!__privateGet(this, _dragging)) {
        requestAnimationFrame(() => {
          var _a;
          if (!__privateGet(this, _activeDOMRect))
            return;
          (_a = __privateGet(this, _BlockService_instances, view_get)) == null ? void 0 : _a.focus();
        });
        return;
      }
      __privateSet(this, _dragging, false);
      __privateSet(this, _activeSelection, null);
    });
    __privateSet(this, _handleDragStart, (event) => {
      var _a;
      __privateSet(this, _dragging, true);
      const view = __privateGet(this, _BlockService_instances, view_get);
      if (!view)
        return;
      view.dom.dataset.dragging = "true";
      const selection = __privateGet(this, _activeSelection);
      if (event.dataTransfer && selection) {
        const slice = selection.content();
        event.dataTransfer.effectAllowed = "copyMove";
        const { dom, text } = serializeForClipboard(view, slice);
        event.dataTransfer.clearData();
        event.dataTransfer.setData(
          brokenClipboardAPI ? "Text" : "text/html",
          dom.innerHTML
        );
        if (!brokenClipboardAPI)
          event.dataTransfer.setData("text/plain", text);
        const activeEl = (_a = __privateGet(this, _active)) == null ? void 0 : _a.el;
        if (activeEl)
          event.dataTransfer.setDragImage(activeEl, 0, 0);
        view.dragging = {
          slice,
          move: true
        };
      }
    });
    this.keydownCallback = (view) => {
      __privateGet(this, _hide).call(this);
      __privateSet(this, _dragging, false);
      view.dom.dataset.dragging = "false";
      return false;
    };
    __privateSet(this, _mousemoveCallback, (0, import_lodash.default)((view, event) => {
      if (!view.editable)
        return;
      const rect = view.dom.getBoundingClientRect();
      const x = rect.left + rect.width / 2;
      const dom = view.root.elementFromPoint(x, event.clientY);
      if (!(dom instanceof Element)) {
        __privateGet(this, _hide).call(this);
        return;
      }
      const filterNodes = __privateGet(this, _BlockService_instances, filterNodes_get);
      if (!filterNodes)
        return;
      const result = selectRootNodeByDom(
        view,
        { x, y: event.clientY },
        filterNodes
      );
      if (!result) {
        __privateGet(this, _hide).call(this);
        return;
      }
      __privateGet(this, _show).call(this, result);
    }, 200));
    this.mousemoveCallback = (view, event) => {
      if (view.composing || !view.editable)
        return false;
      __privateGet(this, _mousemoveCallback).call(this, view, event);
      return false;
    };
    this.dragoverCallback = (view, event) => {
      var _a;
      if (__privateGet(this, _dragging)) {
        const root = (_a = __privateGet(this, _BlockService_instances, view_get)) == null ? void 0 : _a.dom.parentElement;
        if (!root)
          return false;
        const hasHorizontalScrollbar = root.scrollHeight > root.clientHeight;
        const rootRect = root.getBoundingClientRect();
        if (hasHorizontalScrollbar) {
          if (root.scrollTop > 0 && Math.abs(event.y - rootRect.y) < buffer) {
            const top = root.scrollTop > 10 ? root.scrollTop - 10 : 0;
            root.scrollTop = top;
            return false;
          }
          const totalHeight = Math.round(view.dom.getBoundingClientRect().height);
          const scrollBottom = Math.round(root.scrollTop + rootRect.height);
          if (scrollBottom < totalHeight && Math.abs(event.y - (rootRect.height + rootRect.y)) < buffer) {
            const top = root.scrollTop + 10;
            root.scrollTop = top;
            return false;
          }
        }
      }
      return false;
    };
    this.dragenterCallback = (view) => {
      if (!view.dragging)
        return;
      __privateSet(this, _dragging, true);
      view.dom.dataset.dragging = "true";
    };
    this.dragleaveCallback = (view, event) => {
      const x = event.clientX;
      const y = event.clientY;
      if (x < 0 || y < 0 || x > window.innerWidth || y > window.innerHeight) {
        __privateSet(this, _active, null);
        __privateGet(this, _dragEnd).call(this, view);
      }
    };
    this.dropCallback = (view) => {
      __privateGet(this, _dragEnd).call(this, view);
      return false;
    };
    this.dragendCallback = (view) => {
      __privateGet(this, _dragEnd).call(this, view);
    };
    __privateSet(this, _dragEnd, (view) => {
      __privateSet(this, _dragging, false);
      view.dom.dataset.dragging = "false";
    });
  }
};
_ctx = /* @__PURE__ */ new WeakMap();
_createSelection = /* @__PURE__ */ new WeakMap();
_activeSelection = /* @__PURE__ */ new WeakMap();
_active = /* @__PURE__ */ new WeakMap();
_activeDOMRect = /* @__PURE__ */ new WeakMap();
_dragging = /* @__PURE__ */ new WeakMap();
_BlockService_instances = /* @__PURE__ */ new WeakSet();
filterNodes_get = function() {
  var _a;
  return (_a = __privateGet(this, _ctx)) == null ? void 0 : _a.get(blockConfig.key).filterNodes;
};
view_get = function() {
  var _a;
  return (_a = __privateGet(this, _ctx)) == null ? void 0 : _a.get(editorViewCtx);
};
_notify = /* @__PURE__ */ new WeakMap();
_hide = /* @__PURE__ */ new WeakMap();
_show = /* @__PURE__ */ new WeakMap();
_handleMouseDown = /* @__PURE__ */ new WeakMap();
_handleMouseUp = /* @__PURE__ */ new WeakMap();
_handleDragStart = /* @__PURE__ */ new WeakMap();
_mousemoveCallback = /* @__PURE__ */ new WeakMap();
_dragEnd = /* @__PURE__ */ new WeakMap();
var blockService = $ctx(() => new BlockService(), "blockService");
var blockServiceInstance = $ctx(
  {},
  "blockServiceInstance"
);
withMeta(blockService, {
  displayName: "Ctx<blockService>"
});
withMeta(blockServiceInstance, {
  displayName: "Ctx<blockServiceInstance>"
});
var blockSpec = $ctx({}, "blockSpec");
withMeta(blockSpec, {
  displayName: "Ctx<blockSpec>"
});
var blockPlugin = $prose((ctx) => {
  const milkdownPluginBlockKey = new PluginKey("MILKDOWN_BLOCK");
  const getService = ctx.get(blockService.key);
  const service = getService();
  ctx.set(blockServiceInstance.key, service);
  const spec = ctx.get(blockSpec.key);
  return new Plugin({
    key: milkdownPluginBlockKey,
    ...spec,
    props: {
      ...spec.props,
      handleDOMEvents: {
        drop: (view) => {
          return service.dropCallback(view);
        },
        pointermove: (view, event) => {
          return service.mousemoveCallback(view, event);
        },
        keydown: (view) => {
          return service.keydownCallback(view);
        },
        dragover: (view, event) => {
          return service.dragoverCallback(view, event);
        },
        dragleave: (view, event) => {
          return service.dragleaveCallback(view, event);
        },
        dragenter: (view) => {
          return service.dragenterCallback(view);
        },
        dragend: (view) => {
          return service.dragendCallback(view);
        }
      }
    }
  });
});
withMeta(blockPlugin, {
  displayName: "Prose<block>"
});
var BlockProvider = class {
  constructor(options) {
    __privateAdd(this, _BlockProvider_instances);
    __privateAdd(this, _element);
    __privateAdd(this, _ctx2);
    __privateAdd(this, _service);
    __privateAdd(this, _activeNode);
    __privateAdd(this, _root);
    __privateAdd(this, _initialized);
    __privateAdd(this, _middleware);
    __privateAdd(this, _floatingUIOptions);
    __privateAdd(this, _getOffset);
    __privateAdd(this, _getPosition);
    __privateAdd(this, _getPlacement);
    __privateSet(this, _activeNode, null);
    __privateSet(this, _initialized, false);
    this.update = () => {
      requestAnimationFrame(() => {
        if (!__privateGet(this, _initialized)) {
          try {
            __privateMethod(this, _BlockProvider_instances, init_fn).call(this);
            __privateSet(this, _initialized, true);
          } catch {
          }
        }
      });
    };
    this.destroy = () => {
      var _a, _b;
      (_a = __privateGet(this, _service)) == null ? void 0 : _a.unBind();
      (_b = __privateGet(this, _service)) == null ? void 0 : _b.removeEvent(__privateGet(this, _element));
      __privateGet(this, _element).remove();
    };
    this.show = (active) => {
      const dom = active.el;
      const editorDom = __privateGet(this, _ctx2).get(editorViewCtx).dom;
      const deriveContext = {
        ctx: __privateGet(this, _ctx2),
        active,
        editorDom,
        blockDom: __privateGet(this, _element)
      };
      const virtualEl = {
        contextElement: dom,
        getBoundingClientRect: () => {
          if (__privateGet(this, _getPosition))
            return __privateGet(this, _getPosition).call(this, deriveContext);
          return dom.getBoundingClientRect();
        }
      };
      const middleware = [flip()];
      if (__privateGet(this, _getOffset)) {
        const offsetOption = __privateGet(this, _getOffset).call(this, deriveContext);
        const offsetExt = offset(offsetOption);
        middleware.push(offsetExt);
      }
      computePosition(virtualEl, __privateGet(this, _element), {
        placement: __privateGet(this, _getPlacement) ? __privateGet(this, _getPlacement).call(this, deriveContext) : "left",
        middleware: [...middleware, ...__privateGet(this, _middleware)],
        ...__privateGet(this, _floatingUIOptions)
      }).then(({ x, y }) => {
        Object.assign(__privateGet(this, _element).style, {
          left: `${x}px`,
          top: `${y}px`
        });
        __privateGet(this, _element).dataset.show = "true";
      });
    };
    this.hide = () => {
      __privateGet(this, _element).dataset.show = "false";
    };
    __privateSet(this, _ctx2, options.ctx);
    __privateSet(this, _element, options.content);
    __privateSet(this, _getOffset, options.getOffset);
    __privateSet(this, _getPosition, options.getPosition);
    __privateSet(this, _getPlacement, options.getPlacement);
    __privateSet(this, _middleware, options.middleware ?? []);
    __privateSet(this, _floatingUIOptions, options.floatingUIOptions ?? {});
    __privateSet(this, _root, options.root);
    this.hide();
  }
  /// The context of current active node.
  get active() {
    return __privateGet(this, _activeNode);
  }
};
_element = /* @__PURE__ */ new WeakMap();
_ctx2 = /* @__PURE__ */ new WeakMap();
_service = /* @__PURE__ */ new WeakMap();
_activeNode = /* @__PURE__ */ new WeakMap();
_root = /* @__PURE__ */ new WeakMap();
_initialized = /* @__PURE__ */ new WeakMap();
_middleware = /* @__PURE__ */ new WeakMap();
_floatingUIOptions = /* @__PURE__ */ new WeakMap();
_getOffset = /* @__PURE__ */ new WeakMap();
_getPosition = /* @__PURE__ */ new WeakMap();
_getPlacement = /* @__PURE__ */ new WeakMap();
_BlockProvider_instances = /* @__PURE__ */ new WeakSet();
init_fn = function() {
  const view = __privateGet(this, _ctx2).get(editorViewCtx);
  const root = __privateGet(this, _root) ?? view.dom.parentElement ?? document.body;
  root.appendChild(__privateGet(this, _element));
  const service = __privateGet(this, _ctx2).get(blockServiceInstance.key);
  service.bind(__privateGet(this, _ctx2), (message) => {
    if (message.type === "hide") {
      this.hide();
      __privateSet(this, _activeNode, null);
    } else if (message.type === "show") {
      this.show(message.active);
      __privateSet(this, _activeNode, message.active);
    }
  });
  __privateSet(this, _service, service);
  __privateGet(this, _service).addEvent(__privateGet(this, _element));
  __privateGet(this, _element).draggable = true;
};
var block = [
  blockSpec,
  blockConfig,
  blockService,
  blockServiceInstance,
  blockPlugin
];
block.key = blockSpec.key;
block.pluginKey = blockPlugin.key;

// ../node_modules/@milkdown/plugin-slash/lib/index.es.js
var import_lodash2 = __toESM(require_lodash());
var __typeError2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck2 = (obj, member, msg) => member.has(obj) || __typeError2("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck2(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck2(obj, member, "access private method"), method);
var _initialized2;
var _middleware2;
var _floatingUIOptions2;
var _root2;
var _debounce;
var _trigger;
var _shouldShow;
var _offset;
var _onUpdate;
var _SlashProvider_instances;
var _shouldShow_fn;
function slashFactory(id) {
  const slashSpec = $ctx(
    {},
    `${id}_SLASH_SPEC`
  );
  const slashPlugin = $prose((ctx) => {
    const spec = ctx.get(slashSpec.key);
    return new Plugin({
      key: new PluginKey(`${id}_SLASH`),
      ...spec
    });
  });
  const result = [slashSpec, slashPlugin];
  result.key = slashSpec.key;
  result.pluginKey = slashPlugin.key;
  slashSpec.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Ctx<slashSpec>|${id}`
  };
  slashPlugin.meta = {
    package: "@milkdown/plugin-slash",
    displayName: `Prose<slash>|${id}`
  };
  return result;
}
var SlashProvider = class {
  constructor(options) {
    __privateAdd2(this, _SlashProvider_instances);
    __privateAdd2(this, _initialized2);
    __privateAdd2(this, _middleware2);
    __privateAdd2(this, _floatingUIOptions2);
    __privateAdd2(this, _root2);
    __privateAdd2(this, _debounce);
    __privateAdd2(this, _trigger);
    __privateAdd2(this, _shouldShow);
    __privateAdd2(this, _offset);
    __privateAdd2(this, _onUpdate);
    __privateSet2(this, _initialized2, false);
    this.onShow = () => {
    };
    this.onHide = () => {
    };
    __privateSet2(this, _onUpdate, (view, prevState) => {
      const { state, composing } = view;
      const { selection, doc } = state;
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const isSame = prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection);
      if (!__privateGet2(this, _initialized2)) {
        const root = __privateGet2(this, _root2) ?? view.dom.parentElement ?? document.body;
        root.appendChild(this.element);
        __privateSet2(this, _initialized2, true);
      }
      if (composing || isSame)
        return;
      if (!__privateGet2(this, _shouldShow).call(this, view, prevState)) {
        this.hide();
        return;
      }
      const virtualEl = {
        getBoundingClientRect: () => posToDOMRect(view, from, to)
      };
      computePosition(virtualEl, this.element, {
        placement: "bottom-start",
        middleware: [flip(), offset(__privateGet2(this, _offset)), ...__privateGet2(this, _middleware2)],
        ...__privateGet2(this, _floatingUIOptions2)
      }).then(({ x, y }) => {
        Object.assign(this.element.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      });
      this.show();
    });
    this.update = (view, prevState) => {
      const updater = (0, import_lodash2.default)(__privateGet2(this, _onUpdate), __privateGet2(this, _debounce));
      updater(view, prevState);
    };
    this.getContent = (view, matchNode = (node) => node.type.name === "paragraph") => {
      const { selection } = view.state;
      const { empty, $from } = selection;
      const isTextBlock = view.state.selection instanceof TextSelection;
      const isSlashChildren = this.element.contains(document.activeElement);
      const notHasFocus = !view.hasFocus() && !isSlashChildren;
      const isReadonly = !view.editable;
      const paragraph = findParentNode(matchNode)(view.state.selection);
      const isNotInParagraph = !paragraph;
      if (notHasFocus || isReadonly || !empty || !isTextBlock || isNotInParagraph)
        return;
      return $from.parent.textBetween(
        Math.max(0, $from.parentOffset - 500),
        $from.parentOffset,
        void 0,
        "ï¿¼"
      );
    };
    this.destroy = () => {
    };
    this.show = () => {
      this.element.dataset.show = "true";
      this.onShow();
    };
    this.hide = () => {
      this.element.dataset.show = "false";
      this.onHide();
    };
    this.element = options.content;
    __privateSet2(this, _debounce, options.debounce ?? 200);
    __privateSet2(this, _shouldShow, options.shouldShow ?? __privateMethod2(this, _SlashProvider_instances, _shouldShow_fn));
    __privateSet2(this, _trigger, options.trigger ?? "/");
    __privateSet2(this, _offset, options.offset);
    __privateSet2(this, _middleware2, options.middleware ?? []);
    __privateSet2(this, _floatingUIOptions2, options.floatingUIOptions ?? {});
    __privateSet2(this, _root2, options.root);
  }
};
_initialized2 = /* @__PURE__ */ new WeakMap();
_middleware2 = /* @__PURE__ */ new WeakMap();
_floatingUIOptions2 = /* @__PURE__ */ new WeakMap();
_root2 = /* @__PURE__ */ new WeakMap();
_debounce = /* @__PURE__ */ new WeakMap();
_trigger = /* @__PURE__ */ new WeakMap();
_shouldShow = /* @__PURE__ */ new WeakMap();
_offset = /* @__PURE__ */ new WeakMap();
_onUpdate = /* @__PURE__ */ new WeakMap();
_SlashProvider_instances = /* @__PURE__ */ new WeakSet();
_shouldShow_fn = function(view) {
  const currentTextBlockContent = this.getContent(view);
  if (!currentTextBlockContent)
    return false;
  const target = currentTextBlockContent.at(-1);
  if (!target)
    return false;
  return Array.isArray(__privateGet2(this, _trigger)) ? __privateGet2(this, _trigger).includes(target) : __privateGet2(this, _trigger) === target;
};

// ../node_modules/@milkdown/crepe/lib/esm/index-CEOsxgzJ.js
var __typeError$2 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck$2 = (obj, member, msg) => member.has(obj) || __typeError$2("Cannot " + msg);
var __privateGet$2 = (obj, member, getter) => (__accessCheck$2(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$2 = (obj, member, value, setter) => (__accessCheck$2(obj, member, "write to private field"), member.set(obj, value), value);
var _groups;
var _getGroupInstance;
var GroupBuilder = class {
  constructor() {
    __privateAdd$2(this, _groups, []);
    this.clear = () => {
      __privateSet$2(this, _groups, []);
      return this;
    };
    __privateAdd$2(this, _getGroupInstance, (group) => {
      const groupInstance = {
        group,
        addItem: (key, item) => {
          const data = { key, ...item };
          group.items.push(data);
          return groupInstance;
        },
        clear: () => {
          group.items = [];
          return groupInstance;
        }
      };
      return groupInstance;
    });
    this.addGroup = (key, label) => {
      const items = [];
      const group = {
        key,
        label,
        items
      };
      __privateGet$2(this, _groups).push(group);
      return __privateGet$2(this, _getGroupInstance).call(this, group);
    };
    this.getGroup = (key) => {
      const group = __privateGet$2(this, _groups).find((group2) => group2.key === key);
      if (!group)
        throw new Error(`Group with key ${key} not found`);
      return __privateGet$2(this, _getGroupInstance).call(this, group);
    };
    this.build = () => {
      return __privateGet$2(this, _groups);
    };
  }
};
_groups = /* @__PURE__ */ new WeakMap();
_getGroupInstance = /* @__PURE__ */ new WeakMap();
function clearRange(tr) {
  const { $from, $to } = tr.selection;
  const { pos: from } = $from;
  const { pos: to } = $to;
  tr = tr.deleteRange(from - $from.node().content.size, to);
  return tr;
}
function setBlockType(tr, nodeType, attrs = null) {
  const { from, to } = tr.selection;
  return tr.setBlockType(from, to, nodeType, attrs);
}
function wrapInBlockType(tr, nodeType, attrs = null) {
  const { $from, $to } = tr.selection;
  const range = $from.blockRange($to);
  const wrapping = range && findWrapping(range, nodeType, attrs);
  if (!wrapping)
    return null;
  return tr.wrap(range, wrapping);
}
function addBlockType(tr, nodeType, attrs = null) {
  const node = nodeType.createAndFill(attrs);
  if (!node)
    return null;
  return tr.replaceSelectionWith(node);
}
function clearContentAndSetBlockType(nodeType, attrs = null) {
  return (state, dispatch) => {
    if (dispatch) {
      const tr = setBlockType(clearRange(state.tr), nodeType, attrs);
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function clearContentAndWrapInBlockType(nodeType, attrs = null) {
  return (state, dispatch) => {
    const tr = wrapInBlockType(clearRange(state.tr), nodeType, attrs);
    if (!tr)
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function clearContentAndAddBlockType(nodeType, attrs = null) {
  return (state, dispatch) => {
    const tr = addBlockType(clearRange(state.tr), nodeType, attrs);
    if (!tr)
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function getGroups(filter, config, ctx) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z;
  const flags = ctx == null ? void 0 : ctx.get(FeaturesCtx);
  const isLatexEnabled = flags == null ? void 0 : flags.includes(CrepeFeature.Latex);
  const isImageBlockEnabled = flags == null ? void 0 : flags.includes(CrepeFeature.ImageBlock);
  const isTableEnabled = flags == null ? void 0 : flags.includes(CrepeFeature.Table);
  const groupBuilder = new GroupBuilder();
  groupBuilder.addGroup("text", (_a = config == null ? void 0 : config.slashMenuTextGroupLabel) != null ? _a : "Text").addItem("text", {
    label: (_b = config == null ? void 0 : config.slashMenuTextGroupLabel) != null ? _b : "Text",
    icon: (_d = (_c = config == null ? void 0 : config.slashMenuTextIcon) == null ? void 0 : _c.call(config)) != null ? _d : textIcon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(paragraphSchema.type(ctx2));
      command(state, dispatch);
    }
  }).addItem("h1", {
    label: (_e = config == null ? void 0 : config.slashMenuH1Label) != null ? _e : "Heading 1",
    icon: (_g = (_f = config == null ? void 0 : config.slashMenuH1Icon) == null ? void 0 : _f.call(config)) != null ? _g : h1Icon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(headingSchema.type(ctx2), {
        level: 1
      });
      command(state, dispatch);
    }
  }).addItem("h2", {
    label: (_h = config == null ? void 0 : config.slashMenuH2Label) != null ? _h : "Heading 2",
    icon: (_j = (_i = config == null ? void 0 : config.slashMenuH2Icon) == null ? void 0 : _i.call(config)) != null ? _j : h2Icon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(headingSchema.type(ctx2), {
        level: 2
      });
      command(state, dispatch);
    }
  }).addItem("h3", {
    label: (_k = config == null ? void 0 : config.slashMenuH3Label) != null ? _k : "Heading 3",
    icon: (_m = (_l = config == null ? void 0 : config.slashMenuH3Icon) == null ? void 0 : _l.call(config)) != null ? _m : h3Icon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(headingSchema.type(ctx2), {
        level: 3
      });
      command(state, dispatch);
    }
  }).addItem("h4", {
    label: (_n = config == null ? void 0 : config.slashMenuH4Label) != null ? _n : "Heading 4",
    icon: (_p = (_o = config == null ? void 0 : config.slashMenuH4Icon) == null ? void 0 : _o.call(config)) != null ? _p : h4Icon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(headingSchema.type(ctx2), {
        level: 4
      });
      command(state, dispatch);
    }
  }).addItem("h5", {
    label: (_q = config == null ? void 0 : config.slashMenuH5Label) != null ? _q : "Heading 5",
    icon: (_s = (_r = config == null ? void 0 : config.slashMenuH5Icon) == null ? void 0 : _r.call(config)) != null ? _s : h5Icon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(headingSchema.type(ctx2), {
        level: 5
      });
      command(state, dispatch);
    }
  }).addItem("h6", {
    label: (_t = config == null ? void 0 : config.slashMenuH6Label) != null ? _t : "Heading 6",
    icon: (_v = (_u = config == null ? void 0 : config.slashMenuH6Icon) == null ? void 0 : _u.call(config)) != null ? _v : h6Icon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndSetBlockType(headingSchema.type(ctx2), {
        level: 6
      });
      command(state, dispatch);
    }
  }).addItem("quote", {
    label: (_w = config == null ? void 0 : config.slashMenuQuoteLabel) != null ? _w : "Quote",
    icon: (_y = (_x = config == null ? void 0 : config.slashMenuQuoteIcon) == null ? void 0 : _x.call(config)) != null ? _y : quoteIcon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(
        blockquoteSchema.type(ctx2)
      );
      command(state, dispatch);
    }
  }).addItem("divider", {
    label: (_z = config == null ? void 0 : config.slashMenuDividerLabel) != null ? _z : "Divider",
    icon: (_B = (_A = config == null ? void 0 : config.slashMenuDividerIcon) == null ? void 0 : _A.call(config)) != null ? _B : dividerIcon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndAddBlockType(hrSchema.type(ctx2));
      command(state, dispatch);
    }
  });
  groupBuilder.addGroup("list", (_C = config == null ? void 0 : config.slashMenuListGroupLabel) != null ? _C : "List").addItem("bullet-list", {
    label: (_D = config == null ? void 0 : config.slashMenuBulletListLabel) != null ? _D : "Bullet List",
    icon: (_F = (_E = config == null ? void 0 : config.slashMenuBulletListIcon) == null ? void 0 : _E.call(config)) != null ? _F : bulletListIcon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(
        bulletListSchema.type(ctx2)
      );
      command(state, dispatch);
    }
  }).addItem("ordered-list", {
    label: (_G = config == null ? void 0 : config.slashMenuOrderedListLabel) != null ? _G : "Ordered List",
    icon: (_I = (_H = config == null ? void 0 : config.slashMenuOrderedListIcon) == null ? void 0 : _H.call(config)) != null ? _I : orderedListIcon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(
        orderedListSchema.type(ctx2)
      );
      command(state, dispatch);
    }
  }).addItem("todo-list", {
    label: (_J = config == null ? void 0 : config.slashMenuTaskListLabel) != null ? _J : "Todo List",
    icon: (_L = (_K = config == null ? void 0 : config.slashMenuTaskListIcon) == null ? void 0 : _K.call(config)) != null ? _L : todoListIcon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndWrapInBlockType(
        listItemSchema.type(ctx2),
        { checked: false }
      );
      command(state, dispatch);
    }
  });
  const advancedGroup = groupBuilder.addGroup(
    "advanced",
    (_M = config == null ? void 0 : config.slashMenuAdvancedGroupLabel) != null ? _M : "Advanced"
  );
  if (isImageBlockEnabled) {
    advancedGroup.addItem("image", {
      label: (_N = config == null ? void 0 : config.slashMenuImageLabel) != null ? _N : "Image",
      icon: (_P = (_O = config == null ? void 0 : config.slashMenuImageIcon) == null ? void 0 : _O.call(config)) != null ? _P : imageIcon,
      onRun: (ctx2) => {
        const view = ctx2.get(editorViewCtx);
        const { dispatch, state } = view;
        const command = clearContentAndAddBlockType(imageBlockSchema.type(ctx2));
        command(state, dispatch);
      }
    });
  }
  advancedGroup.addItem("code", {
    label: (_Q = config == null ? void 0 : config.slashMenuCodeBlockLabel) != null ? _Q : "Code",
    icon: (_S = (_R = config == null ? void 0 : config.slashMenuCodeBlockIcon) == null ? void 0 : _R.call(config)) != null ? _S : codeIcon,
    onRun: (ctx2) => {
      const view = ctx2.get(editorViewCtx);
      const { dispatch, state } = view;
      const command = clearContentAndAddBlockType(codeBlockSchema.type(ctx2));
      command(state, dispatch);
    }
  });
  if (isTableEnabled) {
    advancedGroup.addItem("table", {
      label: (_T = config == null ? void 0 : config.slashMenuTableLabel) != null ? _T : "Table",
      icon: (_V = (_U = config == null ? void 0 : config.slashMenuTableIcon) == null ? void 0 : _U.call(config)) != null ? _V : tableIcon,
      onRun: (ctx2) => {
        const view = ctx2.get(editorViewCtx);
        const { dispatch, state } = view;
        let { tr } = state;
        tr = clearRange(tr);
        const from = tr.selection.from;
        const table = createTable(ctx2, 3, 3);
        tr = tr.replaceSelectionWith(table);
        dispatch(tr);
        requestAnimationFrame(() => {
          const docSize = view.state.doc.content.size;
          const $pos = view.state.doc.resolve(
            from > docSize ? docSize : from < 0 ? 0 : from
          );
          const selection = TextSelection.near($pos);
          const tr2 = view.state.tr;
          tr2.setSelection(selection);
          dispatch(tr2.scrollIntoView());
        });
      }
    });
  }
  if (isLatexEnabled) {
    advancedGroup.addItem("math", {
      label: (_W = config == null ? void 0 : config.slashMenuMathLabel) != null ? _W : "Math",
      icon: (_Y = (_X = config == null ? void 0 : config.slashMenuMathIcon) == null ? void 0 : _X.call(config)) != null ? _Y : functionsIcon,
      onRun: (ctx2) => {
        const view = ctx2.get(editorViewCtx);
        const { dispatch, state } = view;
        const command = clearContentAndAddBlockType(codeBlockSchema.type(ctx2), {
          language: "LaTex"
        });
        command(state, dispatch);
      }
    });
  }
  (_Z = config == null ? void 0 : config.buildMenu) == null ? void 0 : _Z.call(config, groupBuilder);
  let groups = groupBuilder.build();
  if (filter) {
    groups = groups.map((group) => {
      const items2 = group.items.filter(
        (item) => item.label.toLowerCase().includes(filter.toLowerCase())
      );
      return {
        ...group,
        items: items2
      };
    }).filter((group) => group.items.length > 0);
  }
  const items = groups.flatMap((groups2) => groups2.items);
  items.forEach((item, index) => {
    Object.assign(item, { index });
  });
  groups.reduce((acc, group) => {
    const end = acc + group.items.length;
    Object.assign(group, {
      range: [acc, end]
    });
    return end;
  }, 0);
  return {
    groups,
    size: items.length
  };
}
var menuComponent = ({
  show,
  hide,
  ctx,
  filter,
  config
}) => {
  const { groups, size } = useMemo(
    () => getGroups(filter, config, ctx),
    [filter]
  );
  const host = useHost();
  const [hoverIndex, setHoverIndex] = useState(0);
  const root = useMemo(() => host.current.getRootNode(), [host]);
  const prevMousePosition = useRef({ x: -999, y: -999 });
  const onMouseMove = useCallback((e) => {
    const prevPos = prevMousePosition.current;
    if (!prevPos)
      return;
    const { x, y } = e;
    prevPos.x = x;
    prevPos.y = y;
  }, []);
  useEffect(() => {
    if (size === 0 && show)
      hide == null ? void 0 : hide();
    else if (hoverIndex >= size)
      setHoverIndex(0);
  }, [size, show]);
  const onHover = useCallback(
    (index, after) => {
      setHoverIndex((prev) => {
        const next = typeof index === "function" ? index(prev) : index;
        after == null ? void 0 : after(next);
        return next;
      });
    },
    []
  );
  const scrollToIndex = useCallback((index) => {
    const target = host.current.querySelector(
      `[data-index="${index}"]`
    );
    const scrollRoot = host.current.querySelector(".menu-groups");
    if (!target || !scrollRoot)
      return;
    scrollRoot.scrollTop = target.offsetTop - scrollRoot.offsetTop;
  }, []);
  const runByIndex = useCallback(
    (index) => {
      const item = groups.flatMap((group) => group.items).at(index);
      if (item && ctx)
        item.onRun(ctx);
      hide == null ? void 0 : hide();
    },
    [groups]
  );
  const onKeydown = useCallback(
    (e) => {
      if (e.key === "Escape") {
        e.preventDefault();
        hide == null ? void 0 : hide();
        return;
      }
      if (e.key === "ArrowDown") {
        e.preventDefault();
        return onHover(
          (index) => index < size - 1 ? index + 1 : index,
          scrollToIndex
        );
      }
      if (e.key === "ArrowUp") {
        e.preventDefault();
        return onHover(
          (index) => index <= 0 ? index : index - 1,
          scrollToIndex
        );
      }
      if (e.key === "ArrowLeft") {
        e.preventDefault();
        return onHover((index) => {
          const group = groups.find(
            (group2) => group2.range[0] <= index && group2.range[1] > index
          );
          if (!group)
            return index;
          const prevGroup = groups[groups.indexOf(group) - 1];
          if (!prevGroup)
            return index;
          return prevGroup.range[1] - 1;
        }, scrollToIndex);
      }
      if (e.key === "ArrowRight") {
        e.preventDefault();
        return onHover((index) => {
          const group = groups.find(
            (group2) => group2.range[0] <= index && group2.range[1] > index
          );
          if (!group)
            return index;
          const nextGroup = groups[groups.indexOf(group) + 1];
          if (!nextGroup)
            return index;
          return nextGroup.range[0];
        }, scrollToIndex);
      }
      if (e.key === "Enter") {
        e.preventDefault();
        runByIndex(hoverIndex);
      }
    },
    [hide, groups, hoverIndex]
  );
  const onMouseEnter = useCallback((index) => {
    return (e) => {
      const prevPos = prevMousePosition.current;
      if (!prevPos)
        return;
      const { x, y } = e;
      if (x === prevPos.x && y === prevPos.y)
        return;
      onHover(index);
    };
  }, []);
  useEffect(() => {
    if (show)
      root.addEventListener("keydown", onKeydown, { capture: true });
    else
      root.removeEventListener("keydown", onKeydown, { capture: true });
    return () => {
      root.removeEventListener("keydown", onKeydown, { capture: true });
    };
  }, [show, onKeydown]);
  return html`
    <host onmousedown=${(e) => e.preventDefault()}>
      <nav class="tab-group">
        <ul>
          ${groups.map(
    (group) => html`<li
                key=${group.key}
                onmousedown=${() => onHover(group.range[0], scrollToIndex)}
                class=${hoverIndex >= group.range[0] && hoverIndex < group.range[1] ? "selected" : ""}
              >
                ${group.label}
              </li>`
  )}
        </ul>
      </nav>
      <div class="menu-groups" onmousemove=${onMouseMove}>
        ${groups.map((group) => {
    return html`
            <div key=${group.key} class="menu-group">
              <h6>${group.label}</h6>
              <ul>
                ${group.items.map(
      (item) => html`<li
                      key=${item.key}
                      data-index=${item.index}
                      class=${hoverIndex === item.index ? "hover" : ""}
                      onmouseenter=${onMouseEnter(item.index)}
                      onmousedown=${() => {
        var _a;
        (_a = host.current.querySelector(`[data-index="${item.index}"]`)) == null ? void 0 : _a.classList.add("active");
      }}
                      onmouseup=${() => {
        var _a;
        (_a = host.current.querySelector(`[data-index="${item.index}"]`)) == null ? void 0 : _a.classList.remove("active");
        runByIndex(item.index);
      }}
                    >
                      ${item.icon}
                      <span>${item.label}</span>
                    </li>`
    )}
              </ul>
            </div>
          `;
  })}
      </div>
    </host>
  `;
};
menuComponent.props = {
  ctx: Object,
  config: Object,
  show: Boolean,
  filter: String,
  hide: Function
};
var MenuElement = c(menuComponent);
var __typeError$1 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck$1 = (obj, member, msg) => member.has(obj) || __typeError$1("Cannot " + msg);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet$1 = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), member.set(obj, value), value);
var _content$1;
var _slashProvider;
var _programmaticallyPos;
var menu = slashFactory("CREPE_MENU");
var menuAPI = $ctx(
  {
    show: () => {
    },
    hide: () => {
    }
  },
  "menuAPICtx"
);
defIfNotExists("milkdown-slash-menu", MenuElement);
function configureMenu(ctx, config) {
  ctx.set(menu.key, {
    view: (view) => new MenuView(ctx, view, config)
  });
}
var MenuView = class {
  constructor(ctx, view, config) {
    __privateAdd$1(this, _content$1);
    __privateAdd$1(this, _slashProvider);
    __privateAdd$1(this, _programmaticallyPos, null);
    this.update = (view2) => {
      __privateGet$1(this, _slashProvider).update(view2);
    };
    this.show = (pos) => {
      __privateSet$1(this, _programmaticallyPos, pos);
      __privateGet$1(this, _content$1).filter = "";
      __privateGet$1(this, _slashProvider).show();
    };
    this.hide = () => {
      __privateSet$1(this, _programmaticallyPos, null);
      __privateGet$1(this, _slashProvider).hide();
    };
    this.destroy = () => {
      __privateGet$1(this, _slashProvider).destroy();
      __privateGet$1(this, _content$1).remove();
    };
    __privateSet$1(this, _content$1, new MenuElement());
    __privateGet$1(this, _content$1).hide = this.hide;
    __privateGet$1(this, _content$1).ctx = ctx;
    __privateGet$1(this, _content$1).config = config;
    const self = this;
    __privateSet$1(this, _slashProvider, new SlashProvider({
      content: __privateGet$1(this, _content$1),
      debounce: 20,
      shouldShow(view2) {
        if (isInCodeBlock(view2.state.selection) || isInList(view2.state.selection))
          return false;
        const currentText = this.getContent(
          view2,
          (node) => ["paragraph", "heading"].includes(node.type.name)
        );
        if (currentText == null)
          return false;
        if (!isSelectionAtEndOfNode(view2.state.selection)) {
          return false;
        }
        const pos = __privateGet$1(self, _programmaticallyPos);
        __privateGet$1(self, _content$1).filter = currentText.startsWith("/") ? currentText.slice(1) : currentText;
        if (typeof pos === "number") {
          if (view2.state.doc.resolve(pos).node() !== view2.state.doc.resolve(view2.state.selection.from).node()) {
            __privateSet$1(self, _programmaticallyPos, null);
            return false;
          }
          return true;
        }
        if (!currentText.startsWith("/"))
          return false;
        return true;
      },
      offset: 10
    }));
    __privateGet$1(this, _slashProvider).onShow = () => {
      __privateGet$1(this, _content$1).show = true;
    };
    __privateGet$1(this, _slashProvider).onHide = () => {
      __privateGet$1(this, _content$1).show = false;
    };
    this.update(view);
    ctx.set(menuAPI.key, {
      show: (pos) => this.show(pos),
      hide: () => this.hide()
    });
  }
};
_content$1 = /* @__PURE__ */ new WeakMap();
_slashProvider = /* @__PURE__ */ new WeakMap();
_programmaticallyPos = /* @__PURE__ */ new WeakMap();
function isSelectionAtEndOfNode(selection) {
  if (!(selection instanceof TextSelection))
    return false;
  const { $head } = selection;
  const parent = $head.parent;
  const offset2 = $head.parentOffset;
  return offset2 === parent.content.size;
}
var blockHandleComponent = ({
  onAdd,
  addIcon,
  handleIcon
}) => {
  const ref = useRef();
  useEffect(() => {
    var _a;
    (_a = ref.current) == null ? void 0 : _a.classList.remove("active");
  });
  const onMouseDown = (e) => {
    var _a;
    e.preventDefault();
    e.stopPropagation();
    (_a = ref.current) == null ? void 0 : _a.classList.add("active");
  };
  const onMouseUp = (e) => {
    var _a;
    e.preventDefault();
    e.stopPropagation();
    onAdd == null ? void 0 : onAdd();
    (_a = ref.current) == null ? void 0 : _a.classList.remove("active");
  };
  return html`
    <host>
      <div
        ref=${ref}
        onmousedown=${onMouseDown}
        onmouseup=${onMouseUp}
        class="operation-item"
      >
        ${(addIcon == null ? void 0 : addIcon()) || plusIcon}
      </div>
      <div class="operation-item">${(handleIcon == null ? void 0 : handleIcon()) || menuIcon}</div>
    </host>
  `;
};
blockHandleComponent.props = {
  show: Boolean,
  onAdd: Function,
  addIcon: Function,
  handleIcon: Function
};
var BlockHandleElement = c(blockHandleComponent);
var __typeError3 = (msg) => {
  throw TypeError(msg);
};
var __accessCheck3 = (obj, member, msg) => member.has(obj) || __typeError3("Cannot " + msg);
var __privateGet3 = (obj, member, getter) => (__accessCheck3(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd3 = (obj, member, value) => member.has(obj) ? __typeError3("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet3 = (obj, member, value, setter) => (__accessCheck3(obj, member, "write to private field"), member.set(obj, value), value);
var _content;
var _provider;
var _ctx3;
var BlockHandleView = class {
  constructor(ctx, config) {
    __privateAdd3(this, _content);
    __privateAdd3(this, _provider);
    __privateAdd3(this, _ctx3);
    this.update = () => {
      __privateGet3(this, _provider).update();
    };
    this.destroy = () => {
      __privateGet3(this, _provider).destroy();
      __privateGet3(this, _content).remove();
    };
    this.onAdd = () => {
      const ctx2 = __privateGet3(this, _ctx3);
      const view = ctx2.get(editorViewCtx);
      if (!view.hasFocus())
        view.focus();
      const { state, dispatch } = view;
      const active = __privateGet3(this, _provider).active;
      if (!active)
        return;
      const $pos = active.$pos;
      const pos = $pos.pos + active.node.nodeSize;
      let tr = state.tr.insert(pos, paragraphSchema.type(ctx2).create());
      tr = tr.setSelection(TextSelection.near(tr.doc.resolve(pos)));
      dispatch(tr.scrollIntoView());
      __privateGet3(this, _provider).hide();
      ctx2.get(menuAPI.key).show(tr.selection.from);
    };
    __privateSet3(this, _ctx3, ctx);
    const content = new BlockHandleElement();
    __privateSet3(this, _content, content);
    __privateGet3(this, _content).onAdd = this.onAdd;
    __privateGet3(this, _content).addIcon = config == null ? void 0 : config.handleAddIcon;
    __privateGet3(this, _content).handleIcon = config == null ? void 0 : config.handleDragIcon;
    __privateSet3(this, _provider, new BlockProvider({
      ctx,
      content,
      getOffset: () => 16,
      getPlacement: ({ active, blockDom }) => {
        if (active.node.type.name === "heading")
          return "left";
        let totalDescendant = 0;
        active.node.descendants((node) => {
          totalDescendant += node.childCount;
        });
        const dom = active.el;
        const domRect = dom.getBoundingClientRect();
        const handleRect = blockDom.getBoundingClientRect();
        const style = window.getComputedStyle(dom);
        const paddingTop = Number.parseInt(style.paddingTop, 10) || 0;
        const paddingBottom = Number.parseInt(style.paddingBottom, 10) || 0;
        const height = domRect.height - paddingTop - paddingBottom;
        const handleHeight = handleRect.height;
        return totalDescendant > 2 || handleHeight < height ? "left-start" : "left";
      }
    }));
    this.update();
  }
};
_content = /* @__PURE__ */ new WeakMap();
_provider = /* @__PURE__ */ new WeakMap();
_ctx3 = /* @__PURE__ */ new WeakMap();
defIfNotExists("milkdown-block-handle", BlockHandleElement);
function configureBlockHandle(ctx, config) {
  ctx.set(blockConfig.key, {
    filterNodes: (pos) => {
      const filter = findParent(
        (node) => ["table", "blockquote", "math_inline"].includes(node.type.name)
      )(pos);
      if (filter)
        return false;
      return true;
    }
  });
  ctx.set(block.key, {
    view: () => new BlockHandleView(ctx, config)
  });
}
var defineFeature = (editor, config) => {
  editor.config((ctx) => configureBlockHandle(ctx, config)).config((ctx) => configureMenu(ctx, config)).use(menuAPI).use(block).use(menu);
};
export {
  defineFeature
};
//# sourceMappingURL=index-CEOsxgzJ-V3QR2BPL.js.map
