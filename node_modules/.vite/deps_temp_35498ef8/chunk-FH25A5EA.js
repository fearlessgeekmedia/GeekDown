import {
  require_lodash
} from "./chunk-UNWTUWLU.js";
import {
  gfm
} from "./chunk-PGGLTGNE.js";
import {
  history,
  redo,
  undo
} from "./chunk-PSFXF772.js";
import {
  commonmark
} from "./chunk-FYJHHHFW.js";
import {
  $command,
  $ctx,
  $prose,
  $shortcut,
  $useKeymap,
  AllSelection,
  DOMParser,
  DOMSerializer,
  Editor,
  EditorStatus,
  EditorViewReady,
  InitReady,
  Plugin,
  PluginKey,
  SerializerReady,
  TextSelection,
  commandsCtx,
  createSlice,
  defaultValueCtx,
  editorViewOptionsCtx,
  getMarkdown,
  getNodeFromSchema,
  parserCtx,
  prosePluginsCtx,
  rootCtx,
  schemaCtx,
  serializerCtx
} from "./chunk-SFBFV7Z3.js";
import {
  __toESM
} from "./chunk-NNPG3NYD.js";

// ../node_modules/@milkdown/plugin-history/lib/index.es.js
function withMeta(plugin, meta) {
  Object.assign(plugin, {
    meta: {
      package: "@milkdown/plugin-history",
      ...meta
    }
  });
  return plugin;
}
var undoCommand = $command("Undo", () => () => undo);
withMeta(undoCommand, {
  displayName: "Command<undo>"
});
var redoCommand = $command("Redo", () => () => redo);
withMeta(redoCommand, {
  displayName: "Command<redo>"
});
var historyProviderConfig = $ctx({}, "historyProviderConfig");
withMeta(historyProviderConfig, {
  displayName: "Ctx<historyProviderConfig>"
});
var historyProviderPlugin = $prose(
  (ctx) => history(ctx.get(historyProviderConfig.key))
);
withMeta(historyProviderPlugin, {
  displayName: "Ctx<historyProviderPlugin>"
});
var historyKeymap = $useKeymap("historyKeymap", {
  Undo: {
    shortcuts: "Mod-z",
    command: (ctx) => {
      const commands = ctx.get(commandsCtx);
      return () => commands.call(undoCommand.key);
    }
  },
  Redo: {
    shortcuts: ["Mod-y", "Shift-Mod-z"],
    command: (ctx) => {
      const commands = ctx.get(commandsCtx);
      return () => commands.call(redoCommand.key);
    }
  }
});
withMeta(historyKeymap.ctx, {
  displayName: "KeymapCtx<history>"
});
withMeta(historyKeymap.shortcuts, {
  displayName: "Keymap<history>"
});
var history2 = [
  historyProviderConfig,
  historyProviderPlugin,
  historyKeymap,
  undoCommand,
  redoCommand
].flat();

// ../node_modules/@milkdown/plugin-indent/lib/index.es.js
function updateIndent(tr, options) {
  const { doc, selection } = tr;
  if (!doc || !selection)
    return tr;
  if (!(selection instanceof TextSelection || selection instanceof AllSelection))
    return tr;
  const { to } = selection;
  const text = options.type === "space" ? Array(options.size).fill(" ").join("") : "	";
  return tr.insertText(text, to);
}
var indentConfig = $ctx(
  { type: "space", size: 2 },
  "indentConfig"
);
indentConfig.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Ctx<indentConfig>"
};
var indentPlugin = $shortcut((ctx) => ({
  Tab: (state, dispatch) => {
    const config = ctx.get(indentConfig.key);
    const { tr } = state;
    const _tr = updateIndent(tr, config);
    if (_tr.docChanged) {
      dispatch == null ? void 0 : dispatch(_tr);
      return true;
    }
    return false;
  }
}));
indentPlugin.meta = {
  package: "@milkdown/plugin-indent",
  displayName: "Shortcut<indent>"
};
var indent = [indentConfig, indentPlugin];

// ../node_modules/@milkdown/plugin-clipboard/lib/index.es.js
function isPureText(content) {
  if (!content)
    return false;
  if (Array.isArray(content)) {
    if (content.length > 1)
      return false;
    return isPureText(content[0]);
  }
  const child = content.content;
  if (child)
    return isPureText(child);
  return content.type === "text";
}
function isTextOnlySlice(slice) {
  if (slice.content.childCount === 1) {
    const node = slice.content.firstChild;
    if ((node == null ? void 0 : node.type.name) === "text" && node.marks.length === 0)
      return node;
    if ((node == null ? void 0 : node.type.name) === "paragraph" && node.childCount === 1) {
      const _node = node.firstChild;
      if ((_node == null ? void 0 : _node.type.name) === "text" && _node.marks.length === 0)
        return _node;
    }
  }
  return false;
}
var clipboard = $prose((ctx) => {
  const schema = ctx.get(schemaCtx);
  ctx.update(editorViewOptionsCtx, (prev) => ({
    ...prev,
    editable: prev.editable ?? (() => true)
  }));
  const key2 = new PluginKey("MILKDOWN_CLIPBOARD");
  const plugin = new Plugin({
    key: key2,
    props: {
      handlePaste: (view, event) => {
        var _a, _b;
        const parser = ctx.get(parserCtx);
        const editable = (_b = (_a = view.props).editable) == null ? void 0 : _b.call(_a, view.state);
        const { clipboardData } = event;
        if (!editable || !clipboardData)
          return false;
        const currentNode = view.state.selection.$from.node();
        if (currentNode.type.spec.code)
          return false;
        const text = clipboardData.getData("text/plain");
        const vscodeData = clipboardData.getData("vscode-editor-data");
        if (vscodeData) {
          const data = JSON.parse(vscodeData);
          const language = data == null ? void 0 : data.mode;
          if (text && language) {
            const { tr } = view.state;
            const codeBlock = getNodeFromSchema("code_block", schema);
            tr.replaceSelectionWith(codeBlock.create({ language })).setSelection(
              TextSelection.near(
                tr.doc.resolve(Math.max(0, tr.selection.from - 2))
              )
            ).insertText(text.replace(/\r\n?/g, "\n"));
            view.dispatch(tr);
            return true;
          }
        }
        const html = clipboardData.getData("text/html");
        if (html.length === 0 && text.length === 0)
          return false;
        const domParser = DOMParser.fromSchema(schema);
        let dom;
        if (html.length === 0) {
          const slice2 = parser(text);
          if (!slice2 || typeof slice2 === "string")
            return false;
          dom = DOMSerializer.fromSchema(schema).serializeFragment(
            slice2.content
          );
        } else {
          const template = document.createElement("template");
          template.innerHTML = html;
          dom = template.content.cloneNode(true);
          template.remove();
        }
        const slice = domParser.parseSlice(dom);
        const node = isTextOnlySlice(slice);
        if (node) {
          view.dispatch(view.state.tr.replaceSelectionWith(node, true));
          return true;
        }
        view.dispatch(view.state.tr.replaceSelection(slice));
        return true;
      },
      clipboardTextSerializer: (slice) => {
        const serializer = ctx.get(serializerCtx);
        const isText = isPureText(slice.content.toJSON());
        if (isText)
          return slice.content.textBetween(
            0,
            slice.content.size,
            "\n\n"
          );
        const doc = schema.topNodeType.createAndFill(void 0, slice.content);
        if (!doc)
          return "";
        const value = serializer(doc);
        return value;
      }
    }
  });
  return plugin;
});
clipboard.meta = {
  displayName: "Prose<clipboard>",
  package: "@milkdown/plugin-clipboard"
};

// ../node_modules/@milkdown/plugin-trailing/lib/index.es.js
var trailingConfig = $ctx(
  {
    shouldAppend: (lastNode) => {
      if (!lastNode)
        return false;
      if (["heading", "paragraph"].includes(lastNode.type.name))
        return false;
      return true;
    },
    getNode: (state) => state.schema.nodes.paragraph.create()
  },
  "trailingConfig"
);
trailingConfig.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Ctx<trailingConfig>"
};
var trailingPlugin = $prose((ctx) => {
  const trailingPluginKey = new PluginKey("MILKDOWN_TRAILING");
  const { shouldAppend, getNode } = ctx.get(trailingConfig.key);
  const plugin = new Plugin({
    key: trailingPluginKey,
    state: {
      init: (_, state) => {
        const lastNode = state.tr.doc.lastChild;
        return shouldAppend(lastNode, state);
      },
      apply: (tr, value, _, state) => {
        if (!tr.docChanged)
          return value;
        const lastNode = tr.doc.lastChild;
        return shouldAppend(lastNode, state);
      }
    },
    appendTransaction: (_, __, state) => {
      const { doc, tr } = state;
      const nodeType = getNode == null ? void 0 : getNode(state);
      const shouldInsertNodeAtEnd = plugin.getState(state);
      const endPosition = doc.content.size;
      if (!shouldInsertNodeAtEnd || !nodeType)
        return;
      return tr.insert(endPosition, nodeType);
    }
  });
  return plugin;
});
trailingPlugin.meta = {
  package: "@milkdown/plugin-trailing",
  displayName: "Prose<trailing>"
};
var trailing = [trailingConfig, trailingPlugin];

// ../node_modules/@milkdown/plugin-listener/lib/index.es.js
var import_lodash = __toESM(require_lodash());
var ListenerManager = class {
  constructor() {
    this.beforeMountedListeners = [];
    this.mountedListeners = [];
    this.updatedListeners = [];
    this.markdownUpdatedListeners = [];
    this.blurListeners = [];
    this.focusListeners = [];
    this.destroyListeners = [];
    this.beforeMount = (fn) => {
      this.beforeMountedListeners.push(fn);
      return this;
    };
    this.mounted = (fn) => {
      this.mountedListeners.push(fn);
      return this;
    };
    this.updated = (fn) => {
      this.updatedListeners.push(fn);
      return this;
    };
  }
  /// A getter to get all [subscribers](#interface-subscribers). You should not use this method directly.
  get listeners() {
    return {
      beforeMount: this.beforeMountedListeners,
      mounted: this.mountedListeners,
      updated: this.updatedListeners,
      markdownUpdated: this.markdownUpdatedListeners,
      blur: this.blurListeners,
      focus: this.focusListeners,
      destroy: this.destroyListeners
    };
  }
  /// Subscribe to the markdownUpdated event.
  /// This event will be triggered after the editor state is updated and **the document is changed**.
  /// The second parameter is the current markdown and the third parameter is the previous markdown.
  markdownUpdated(fn) {
    this.markdownUpdatedListeners.push(fn);
    return this;
  }
  /// Subscribe to the blur event.
  /// This event will be triggered when the editor is blurred.
  blur(fn) {
    this.blurListeners.push(fn);
    return this;
  }
  /// Subscribe to the focus event.
  /// This event will be triggered when the editor is focused.
  focus(fn) {
    this.focusListeners.push(fn);
    return this;
  }
  /// Subscribe to the destroy event.
  /// This event will be triggered before the editor is destroyed.
  destroy(fn) {
    this.destroyListeners.push(fn);
    return this;
  }
};
var listenerCtx = createSlice(
  new ListenerManager(),
  "listener"
);
var key = new PluginKey("MILKDOWN_LISTENER");
var listener = (ctx) => {
  ctx.inject(listenerCtx, new ListenerManager());
  return async () => {
    await ctx.wait(InitReady);
    const listener2 = ctx.get(listenerCtx);
    const { listeners } = listener2;
    listeners.beforeMount.forEach((fn) => fn(ctx));
    await ctx.wait(SerializerReady);
    const serializer = ctx.get(serializerCtx);
    let prevDoc = null;
    let prevMarkdown = null;
    const plugin = new Plugin({
      key,
      view: () => {
        return {
          destroy: () => {
            listeners.destroy.forEach((fn) => fn(ctx));
          }
        };
      },
      props: {
        handleDOMEvents: {
          focus: () => {
            listeners.focus.forEach((fn) => fn(ctx));
            return false;
          },
          blur: () => {
            listeners.blur.forEach((fn) => fn(ctx));
            return false;
          }
        }
      },
      state: {
        init: (_, instance) => {
          prevDoc = instance.doc;
          prevMarkdown = serializer(instance.doc);
        },
        apply: (tr) => {
          if (!tr.docChanged || tr.getMeta("addToHistory") === false)
            return;
          const handler = (0, import_lodash.default)(() => {
            const { doc } = tr;
            if (listeners.updated.length > 0 && prevDoc && !prevDoc.eq(doc)) {
              listeners.updated.forEach((fn) => {
                fn(ctx, doc, prevDoc);
              });
            }
            if (listeners.markdownUpdated.length > 0 && prevDoc && !prevDoc.eq(doc)) {
              const markdown = serializer(doc);
              listeners.markdownUpdated.forEach((fn) => {
                fn(ctx, markdown, prevMarkdown);
              });
              prevMarkdown = markdown;
            }
            prevDoc = doc;
          }, 200);
          return handler();
        }
      }
    });
    ctx.update(prosePluginsCtx, (x) => x.concat(plugin));
    await ctx.wait(EditorViewReady);
    listeners.mounted.forEach((fn) => fn(ctx));
  };
};
listener.meta = {
  package: "@milkdown/plugin-listener",
  displayName: "Listener"
};

// ../node_modules/@milkdown/crepe/lib/esm/index-BwTxn2hs.js
var CrepeFeature = ((CrepeFeature2) => {
  CrepeFeature2["CodeMirror"] = "code-mirror";
  CrepeFeature2["ListItem"] = "list-item";
  CrepeFeature2["LinkTooltip"] = "link-tooltip";
  CrepeFeature2["Cursor"] = "cursor";
  CrepeFeature2["ImageBlock"] = "image-block";
  CrepeFeature2["BlockEdit"] = "block-edit";
  CrepeFeature2["Toolbar"] = "toolbar";
  CrepeFeature2["Placeholder"] = "placeholder";
  CrepeFeature2["Table"] = "table";
  CrepeFeature2["Latex"] = "latex";
  return CrepeFeature2;
})(CrepeFeature || {});
var defaultFeatures = {
  [
    "cursor"
    /* Cursor */
  ]: true,
  [
    "list-item"
    /* ListItem */
  ]: true,
  [
    "link-tooltip"
    /* LinkTooltip */
  ]: true,
  [
    "image-block"
    /* ImageBlock */
  ]: true,
  [
    "block-edit"
    /* BlockEdit */
  ]: true,
  [
    "placeholder"
    /* Placeholder */
  ]: true,
  [
    "toolbar"
    /* Toolbar */
  ]: true,
  [
    "code-mirror"
    /* CodeMirror */
  ]: true,
  [
    "table"
    /* Table */
  ]: true,
  [
    "latex"
    /* Latex */
  ]: true
};
async function loadFeature(feature, editor, config) {
  switch (feature) {
    case "code-mirror": {
      const { defineFeature } = await import("./index-B3KiKTSt-J2VQHDA7.js");
      return defineFeature(editor, config);
    }
    case "list-item": {
      const { defineFeature } = await import("./index-Cuk7cL-r-VPUSHRB5.js");
      return defineFeature(editor, config);
    }
    case "link-tooltip": {
      const { defineFeature } = await import("./index-DcRgwPLd-ZIHSWIXJ.js");
      return defineFeature(editor, config);
    }
    case "image-block": {
      const { defineFeature } = await import("./index-BFsG6770-VJKQZL52.js");
      return defineFeature(editor, config);
    }
    case "cursor": {
      const { defineFeature } = await import("./index-CsYl2WR5-ZUPTTNSE.js");
      return defineFeature(editor, config);
    }
    case "block-edit": {
      const { defineFeature } = await import("./index-CEOsxgzJ-V3QR2BPL.js");
      return defineFeature(editor, config);
    }
    case "placeholder": {
      const { defineFeature } = await import("./index-DOrkOhki-FYUTESFC.js");
      return defineFeature(editor, config);
    }
    case "toolbar": {
      const { defineFeature } = await import("./index-H9uklzH0-YP325AL6.js");
      return defineFeature(editor, config);
    }
    case "table": {
      const { defineFeature } = await import("./index-CBrOT1fW-44ARBHBT.js");
      return defineFeature(editor, config);
    }
    case "latex": {
      const { defineFeature } = await import("./index-x2oo_GmY-GUBPPJR2.js");
      return defineFeature(editor, config);
    }
  }
}
var FeaturesCtx = createSlice([], "FeaturesCtx");
var crepeCtx = createSlice({}, "CrepeCtx");
function configureFeatures(features) {
  return (ctx) => {
    ctx.inject(FeaturesCtx, features);
  };
}
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _editor;
var _initPromise;
var _rootElement;
var _editable;
var Crepe = class {
  constructor({
    root,
    features = {},
    featureConfigs = {},
    defaultValue = ""
  }) {
    __privateAdd(this, _editor);
    __privateAdd(this, _initPromise);
    __privateAdd(this, _rootElement);
    __privateAdd(this, _editable, true);
    var _a;
    const enabledFeatures = Object.entries({
      ...defaultFeatures,
      ...features
    }).filter(([, enabled]) => enabled).map(([feature]) => feature);
    __privateSet(this, _rootElement, (_a = typeof root === "string" ? document.querySelector(root) : root) != null ? _a : document.body);
    __privateSet(this, _editor, Editor.make().config((ctx) => {
      ctx.inject(crepeCtx, this);
    }).config(configureFeatures(enabledFeatures)).config((ctx) => {
      ctx.set(rootCtx, __privateGet(this, _rootElement));
      ctx.set(defaultValueCtx, defaultValue);
      ctx.set(editorViewOptionsCtx, {
        editable: () => __privateGet(this, _editable)
      });
      ctx.update(indentConfig.key, (value) => ({
        ...value,
        size: 4
      }));
    }).use(commonmark).use(listener).use(history2).use(indent).use(trailing).use(clipboard).use(gfm));
    const promiseList = [];
    enabledFeatures.forEach((feature) => {
      const config = featureConfigs[feature];
      promiseList.push(loadFeature(feature, __privateGet(this, _editor), config));
    });
    __privateSet(this, _initPromise, Promise.all(promiseList));
  }
  async create() {
    await __privateGet(this, _initPromise);
    return __privateGet(this, _editor).create();
  }
  async destroy() {
    await __privateGet(this, _initPromise);
    return __privateGet(this, _editor).destroy();
  }
  get editor() {
    return __privateGet(this, _editor);
  }
  setReadonly(value) {
    __privateSet(this, _editable, !value);
    return this;
  }
  getMarkdown() {
    return __privateGet(this, _editor).action(getMarkdown());
  }
  on(fn) {
    if (__privateGet(this, _editor).status !== EditorStatus.Created) {
      __privateGet(this, _editor).config((ctx) => {
        const listener2 = ctx.get(listenerCtx);
        fn(listener2);
      });
      return this;
    }
    __privateGet(this, _editor).action((ctx) => {
      const listener2 = ctx.get(listenerCtx);
      fn(listener2);
    });
    return this;
  }
};
_editor = /* @__PURE__ */ new WeakMap();
_initPromise = /* @__PURE__ */ new WeakMap();
_rootElement = /* @__PURE__ */ new WeakMap();
_editable = /* @__PURE__ */ new WeakMap();
Crepe.Feature = CrepeFeature;

export {
  CrepeFeature,
  FeaturesCtx,
  crepeCtx,
  Crepe
};
//# sourceMappingURL=chunk-FH25A5EA.js.map
