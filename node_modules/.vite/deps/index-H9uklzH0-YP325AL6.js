import {
  linkTooltipAPI
} from "./chunk-7QRG4ONT.js";
import {
  mathInlineSchema
} from "./chunk-MDPOO72R.js";
import {
  TooltipProvider,
  tooltipFactory
} from "./chunk-ITBF6OGV.js";
import {
  defIfNotExists
} from "./chunk-NHCJLS3Q.js";
import "./chunk-CPITEZUQ.js";
import "./chunk-RLNND5KI.js";
import {
  boldIcon,
  c,
  clsx_default,
  codeIcon,
  functionsIcon,
  html,
  italicIcon,
  linkIcon,
  strikethroughIcon,
  useEffect,
  useUpdate
} from "./chunk-QO2MOLLE.js";
import {
  CrepeFeature,
  FeaturesCtx
} from "./chunk-FH25A5EA.js";
import "./chunk-UNWTUWLU.js";
import "./chunk-CX5HPSVS.js";
import {
  strikethroughSchema,
  toggleStrikethroughCommand
} from "./chunk-PGGLTGNE.js";
import "./chunk-PSFXF772.js";
import {
  emphasisSchema,
  inlineCodeSchema,
  linkSchema,
  strongSchema,
  toggleEmphasisCommand,
  toggleInlineCodeCommand,
  toggleStrongCommand
} from "./chunk-FYJHHHFW.js";
import {
  NodeSelection,
  TextSelection,
  commandsCtx,
  editorViewCtx
} from "./chunk-SFBFV7Z3.js";
import "./chunk-VBO2Q2KC.js";
import "./chunk-NNPG3NYD.js";

// ../node_modules/@milkdown/crepe/lib/esm/index-H9uklzH0.js
var toolbarComponent = ({
  ctx,
  hide,
  show,
  config,
  selection
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  const update = useUpdate();
  useEffect(() => {
    update();
  }, [show]);
  const onClick = (fn) => (e) => {
    e.preventDefault();
    ctx && fn(ctx);
    update();
  };
  const isActive = (mark) => {
    if (!ctx || !selection)
      return false;
    const view = ctx.get(editorViewCtx);
    const {
      state: { doc }
    } = view;
    return doc.rangeHasMark(selection.from, selection.to, mark);
  };
  const containsNode = (node) => {
    if (!ctx || !selection)
      return false;
    const view = ctx.get(editorViewCtx);
    const {
      state: { doc }
    } = view;
    if (selection instanceof NodeSelection) {
      return selection.node.type === node;
    }
    const { from, to } = selection;
    let hasNode = false;
    doc.nodesBetween(from, to, (n) => {
      if (n.type === node) {
        hasNode = true;
        return false;
      }
      return true;
    });
    return hasNode;
  };
  const flags = ctx == null ? void 0 : ctx.get(FeaturesCtx);
  const isLatexEnabled = flags == null ? void 0 : flags.includes(CrepeFeature.Latex);
  const toggleLatex = (ctx2) => {
    const hasLatex = containsNode(mathInlineSchema.type(ctx2));
    const view = ctx2.get(editorViewCtx);
    const { selection: selection2, doc, tr } = view.state;
    if (!hasLatex) {
      const text = doc.textBetween(selection2.from, selection2.to);
      let _tr2 = tr.replaceSelectionWith(
        mathInlineSchema.type(ctx2).create({
          value: text
        })
      );
      view.dispatch(
        _tr2.setSelection(NodeSelection.create(_tr2.doc, selection2.from))
      );
      return;
    }
    const { from, to } = selection2;
    let pos = -1;
    let node = null;
    doc.nodesBetween(from, to, (n, p) => {
      if (node)
        return false;
      if (n.type === mathInlineSchema.type(ctx2)) {
        pos = p;
        node = n;
        return false;
      }
      return true;
    });
    if (!node || pos < 0)
      return;
    let _tr = tr.delete(pos, pos + 1);
    const content = node.attrs.value;
    _tr = _tr.insertText(content, pos);
    view.dispatch(
      _tr.setSelection(
        TextSelection.create(_tr.doc, from, to + content.length - 1)
      )
    );
  };
  return html`<host>
    <button
      type="button"
      class=${clsx_default(
    "toolbar-item",
    ctx && isActive(strongSchema.type(ctx)) && "active"
  )}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleStrongCommand.key);
  })}
    >
      ${(_b = (_a = config == null ? void 0 : config.boldIcon) == null ? void 0 : _a.call(config)) != null ? _b : boldIcon}
    </button>
    <button
      type="button"
      class=${clsx_default(
    "toolbar-item",
    ctx && isActive(emphasisSchema.type(ctx)) && "active"
  )}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleEmphasisCommand.key);
  })}
    >
      ${(_d = (_c = config == null ? void 0 : config.italicIcon) == null ? void 0 : _c.call(config)) != null ? _d : italicIcon}
    </button>
    <button
      type="button"
      class=${clsx_default(
    "toolbar-item",
    ctx && isActive(strikethroughSchema.type(ctx)) && "active"
  )}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleStrikethroughCommand.key);
  })}
    >
      ${(_f = (_e = config == null ? void 0 : config.strikethroughIcon) == null ? void 0 : _e.call(config)) != null ? _f : strikethroughIcon}
    </button>
    <div class="divider"></div>
    <button
      type="button"
      class=${clsx_default(
    "toolbar-item",
    ctx && isActive(inlineCodeSchema.type(ctx)) && "active"
  )}
      onmousedown=${onClick((ctx2) => {
    const commands = ctx2.get(commandsCtx);
    commands.call(toggleInlineCodeCommand.key);
  })}
    >
      ${(_h = (_g = config == null ? void 0 : config.codeIcon) == null ? void 0 : _g.call(config)) != null ? _h : codeIcon}
    </button>
    ${isLatexEnabled && html`<button
      type="button"
      class=${clsx_default(
    "toolbar-item",
    ctx && containsNode(mathInlineSchema.type(ctx)) && "active"
  )}
      onmousedown=${onClick(toggleLatex)}
    >
      ${(_j = (_i = config == null ? void 0 : config.latexIcon) == null ? void 0 : _i.call(config)) != null ? _j : functionsIcon}
    </button>`}
    <button
      type="button"
      class=${clsx_default(
    "toolbar-item",
    ctx && isActive(linkSchema.type(ctx)) && "active"
  )}
      onmousedown=${onClick((ctx2) => {
    const view = ctx2.get(editorViewCtx);
    const { selection: selection2 } = view.state;
    if (isActive(linkSchema.type(ctx2))) {
      ctx2.get(linkTooltipAPI.key).removeLink(selection2.from, selection2.to);
      return;
    }
    ctx2.get(linkTooltipAPI.key).addLink(selection2.from, selection2.to);
    hide == null ? void 0 : hide();
  })}
    >
      ${(_l = (_k = config == null ? void 0 : config.linkIcon) == null ? void 0 : _k.call(config)) != null ? _l : linkIcon}
    </button>
  </host>`;
};
toolbarComponent.props = {
  ctx: Object,
  hide: Function,
  show: Boolean,
  config: Object,
  selection: Object
};
var ToolbarElement = c(toolbarComponent);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _tooltipProvider;
var _content;
var toolbar = tooltipFactory("CREPE_TOOLBAR");
var ToolbarView = class {
  constructor(ctx, view, config) {
    __privateAdd(this, _tooltipProvider);
    __privateAdd(this, _content);
    this.update = (view2, prevState) => {
      __privateGet(this, _tooltipProvider).update(view2, prevState);
      __privateGet(this, _content).selection = view2.state.selection;
    };
    this.destroy = () => {
      __privateGet(this, _tooltipProvider).destroy();
      __privateGet(this, _content).remove();
    };
    this.hide = () => {
      __privateGet(this, _tooltipProvider).hide();
    };
    const content = new ToolbarElement();
    __privateSet(this, _content, content);
    __privateGet(this, _content).ctx = ctx;
    __privateGet(this, _content).hide = this.hide;
    __privateGet(this, _content).config = config;
    __privateGet(this, _content).selection = view.state.selection;
    __privateSet(this, _tooltipProvider, new TooltipProvider({
      content: __privateGet(this, _content),
      debounce: 20,
      offset: 10,
      shouldShow(view2) {
        const { doc, selection } = view2.state;
        const { empty, from, to } = selection;
        const isEmptyTextBlock = !doc.textBetween(from, to).length && selection instanceof TextSelection;
        const isNotTextBlock = !(selection instanceof TextSelection);
        const activeElement = view2.dom.getRootNode().activeElement;
        const isTooltipChildren = content.contains(activeElement);
        const notHasFocus = !view2.hasFocus() && !isTooltipChildren;
        const isReadonly = !view2.editable;
        if (notHasFocus || isNotTextBlock || empty || isEmptyTextBlock || isReadonly)
          return false;
        return true;
      }
    }));
    __privateGet(this, _tooltipProvider).onShow = () => {
      __privateGet(this, _content).show = true;
    };
    __privateGet(this, _tooltipProvider).onHide = () => {
      __privateGet(this, _content).show = false;
    };
    this.update(view);
  }
};
_tooltipProvider = /* @__PURE__ */ new WeakMap();
_content = /* @__PURE__ */ new WeakMap();
defIfNotExists("milkdown-toolbar", ToolbarElement);
var defineFeature = (editor, config) => {
  editor.config((ctx) => {
    ctx.set(toolbar.key, {
      view: (view) => new ToolbarView(ctx, view, config)
    });
  }).use(toolbar);
};
export {
  defineFeature
};
//# sourceMappingURL=index-H9uklzH0-YP325AL6.js.map
