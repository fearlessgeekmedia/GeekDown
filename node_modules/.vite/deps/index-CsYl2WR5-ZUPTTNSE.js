import "./chunk-CX5HPSVS.js";
import {
  $ctx,
  $prose,
  Decoration,
  DecorationSet,
  Fragment,
  Mark,
  NodeSelection,
  Plugin,
  PluginKey,
  Selection,
  Slice,
  TextSelection,
  dropPoint,
  keydownHandler
} from "./chunk-SFBFV7Z3.js";
import "./chunk-VBO2Q2KC.js";
import "./chunk-NNPG3NYD.js";

// ../node_modules/prosemirror-dropcursor/dist/index.js
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = class {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      parentLeft = rect2.left - parent.scrollLeft;
      parentTop = rect2.top - parent.scrollTop;
    }
    this.element.style.left = rect.left - parentLeft + "px";
    this.element.style.top = rect.top - parentTop + "px";
    this.element.style.width = rect.right - rect.left + "px";
    this.element.style.height = rect.bottom - rect.top + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
};

// ../node_modules/prosemirror-gapcursor/dist/index.js
var GapCursor = class _GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc, mapping) {
    let $pos = doc.resolve(mapping.map(this.head));
    return _GapCursor.valid($pos) ? new _GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof _GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new _GapCursor(doc.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search:
      for (; ; ) {
        if (!mustMove && _GapCursor.valid($pos))
          return $pos;
        let pos = $pos.pos, next = null;
        for (let d = $pos.depth; ; d--) {
          let parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        for (; ; ) {
          let inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          let $cur = $pos.doc.resolve(pos);
          if (_GapCursor.valid($cur))
            return $cur;
        }
        return null;
      }
  }
};
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = class _GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new _GapBookmark(mapping.map(this.pos));
  }
  resolve(doc) {
    let $pos = doc.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
};
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
var handleKeyDown = keydownHandler({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}

// ../node_modules/@milkdown/plugin-cursor/lib/index.es.js
function withMeta(plugin, meta) {
  Object.assign(plugin, {
    meta: {
      package: "@milkdown/plugin-cursor",
      ...meta
    }
  });
  return plugin;
}
var dropCursorConfig = $ctx(
  {},
  "dropCursorConfig"
);
withMeta(dropCursorConfig, {
  displayName: "Ctx<dropCursor>"
});
var dropCursorPlugin = $prose(
  (ctx) => dropCursor(ctx.get(dropCursorConfig.key))
);
withMeta(dropCursorPlugin, {
  displayName: "Prose<dropCursor>"
});
var gapCursorPlugin = $prose(() => gapCursor());
withMeta(gapCursorPlugin, {
  displayName: "Prose<gapCursor>"
});
var cursor = [
  dropCursorConfig,
  dropCursorPlugin,
  gapCursorPlugin
];

// ../node_modules/prosemirror-virtual-cursor/dist/index.js
function createVirtualCursor(options) {
  var _a;
  const skipWarning = (_a = options == null ? void 0 : options.skipWarning) != null ? _a : false;
  let _cursor = typeof document === "undefined" ? null : document.createElement("div");
  return new Plugin({
    key,
    view: (view) => {
      if (skipWarning !== true) {
        checkInclusive(view.state.schema, skipWarning || []);
      }
      const doc = view.dom.ownerDocument;
      _cursor = _cursor || document.createElement("div");
      const cursor2 = _cursor;
      const update = () => {
        updateCursor(view, cursor2);
      };
      let observer;
      if (window.ResizeObserver) {
        observer = new window.ResizeObserver(() => update());
        observer.observe(view.dom);
      }
      doc.addEventListener("selectionchange", update);
      return {
        update: () => {
          update();
        },
        destroy: () => {
          doc.removeEventListener("selectionchange", update);
          if (observer) {
            observer.unobserve(view.dom);
          }
        }
      };
    },
    props: {
      handleKeyDown: (view, event) => {
        var _a2;
        const { selection } = view.state;
        if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey || event.isComposing || !["ArrowLeft", "ArrowRight"].includes(event.key) || !isTextSelection(selection) || !selection.empty)
          return false;
        const $pos = selection.$head;
        const [marksBefore, marksAfter] = getMarksAround($pos);
        const marks = view.state.storedMarks || $pos.marks();
        if (marksBefore && marksAfter && !Mark.sameSet(marksBefore, marksAfter)) {
          if (event.key === "ArrowLeft" && !Mark.sameSet(marksBefore, marks)) {
            view.dispatch(view.state.tr.setStoredMarks(marksBefore));
            return true;
          }
          if (event.key === "ArrowRight" && !Mark.sameSet(marksAfter, marks)) {
            view.dispatch(view.state.tr.setStoredMarks(marksAfter));
            return true;
          }
        }
        if (event.key === "ArrowLeft" && $pos.textOffset === 1) {
          view.dispatch(
            view.state.tr.setSelection(TextSelection.create(view.state.doc, $pos.pos - 1)).setStoredMarks($pos.marks())
          );
          return true;
        }
        if (event.key === "ArrowRight" && $pos.textOffset + 1 === ((_a2 = $pos.parent.maybeChild($pos.index())) == null ? void 0 : _a2.nodeSize)) {
          view.dispatch(
            view.state.tr.setSelection(TextSelection.create(view.state.doc, $pos.pos + 1)).setStoredMarks($pos.marks())
          );
          return true;
        }
        return false;
      },
      decorations: (state) => {
        if (!_cursor || !isTextSelection(state.selection) || !state.selection.empty)
          return;
        return DecorationSet.create(state.doc, [
          Decoration.widget(0, _cursor, {
            key: "prosemirror-virtual-cursor"
          })
        ]);
      },
      attributes: {
        class: "virtual-cursor-enabled"
      }
    }
  });
}
var key = new PluginKey("prosemirror-virtual-cursor");
function getCursorRect(view, toStart) {
  var _a;
  const selection = window.getSelection();
  if (!selection || !selection.rangeCount)
    return null;
  const range = (_a = selection == null ? void 0 : selection.getRangeAt(0)) == null ? void 0 : _a.cloneRange();
  if (!range)
    return null;
  range.collapse(toStart);
  const rects = range.getClientRects();
  const rect = (rects == null ? void 0 : rects.length) ? rects[rects.length - 1] : null;
  if (rect == null ? void 0 : rect.height)
    return rect;
  return view.coordsAtPos(view.state.selection.head);
}
function getMarksAround($pos) {
  const index = $pos.index();
  const after = $pos.parent.maybeChild(index);
  let before = $pos.textOffset ? after : null;
  if (!before && index > 0)
    before = $pos.parent.maybeChild(index - 1);
  return [before == null ? void 0 : before.marks, after == null ? void 0 : after.marks];
}
function isTextSelection(selection) {
  return selection && typeof selection === "object" && "$cursor" in selection;
}
function updateCursor(view, cursor2) {
  if (!view || !view.dom || view.isDestroyed || !cursor2)
    return;
  const { state, dom } = view;
  const { selection } = state;
  if (!isTextSelection(selection))
    return;
  const cursorRect = getCursorRect(view, selection.$head === selection.$from);
  if (!cursorRect)
    return cursor2;
  const editorRect = dom.getBoundingClientRect();
  let className = "prosemirror-virtual-cursor";
  const $pos = state.selection.$head;
  const [marksBefore, marksAfter] = getMarksAround($pos);
  const marks = state.storedMarks || $pos.marks();
  if (selection.$cursor && marksBefore && marksAfter && marks && !Mark.sameSet(marksBefore, marksAfter)) {
    if (Mark.sameSet(marksBefore, marks))
      className += " prosemirror-virtual-cursor-left";
    else if (Mark.sameSet(marksAfter, marks))
      className += " prosemirror-virtual-cursor-right";
  }
  cursor2.className = className;
  restartAnimation(cursor2, "prosemirror-virtual-cursor-animation");
  cursor2.style.height = `${cursorRect.bottom - cursorRect.top}px`;
  cursor2.style.left = `${cursorRect.left - editorRect.left}px`;
  cursor2.style.top = `${cursorRect.top - editorRect.top}px`;
}
function restartAnimation(element, className) {
  element.classList.remove(className);
  void element.offsetWidth;
  element.classList.add(className);
}
function checkInclusive(schema, skipWarning) {
  for (const [mark, type] of Object.entries(schema.marks)) {
    if (type.spec.inclusive === false && !skipWarning.includes(mark)) {
      console.warn(
        `[prosemirror-virtual-cursor] Virtual cursor does not work well with marks that have inclusive set to false. Please consider removing the inclusive option from the "${mark}" mark or adding it to the "skipWarning" option.`
      );
    }
  }
}

// ../node_modules/@milkdown/crepe/lib/esm/index-CsYl2WR5.js
var defineFeature = (editor, config) => {
  editor.config((ctx) => {
    ctx.update(dropCursorConfig.key, () => {
      var _a, _b;
      return {
        class: "crepe-drop-cursor",
        width: (_a = config == null ? void 0 : config.width) != null ? _a : 4,
        color: (_b = config == null ? void 0 : config.color) != null ? _b : false
      };
    });
  }).use(cursor);
  if ((config == null ? void 0 : config.virtual) === false) {
    return;
  }
  const virtualCursor = createVirtualCursor();
  editor.use($prose(() => virtualCursor));
};
export {
  defineFeature
};
//# sourceMappingURL=index-CsYl2WR5-ZUPTTNSE.js.map
