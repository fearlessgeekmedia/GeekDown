import {
  require_lodash
} from "./chunk-CPITEZUQ.js";
import {
  computePosition,
  flip,
  offset,
  shift
} from "./chunk-RLNND5KI.js";
import {
  $ctx,
  $prose,
  Plugin,
  PluginKey,
  TextSelection,
  posToDOMRect
} from "./chunk-SFBFV7Z3.js";
import {
  __toESM
} from "./chunk-NNPG3NYD.js";

// ../node_modules/@milkdown/plugin-tooltip/lib/index.es.js
var import_lodash = __toESM(require_lodash());
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _debounce;
var _shouldShow;
var _middleware;
var _floatingUIOptions;
var _root;
var _initialized;
var _offset;
var _onUpdate;
var _TooltipProvider_instances;
var _shouldShow_fn;
var TooltipProvider = class {
  constructor(options) {
    __privateAdd(this, _TooltipProvider_instances);
    __privateAdd(this, _debounce);
    __privateAdd(this, _shouldShow);
    __privateAdd(this, _middleware);
    __privateAdd(this, _floatingUIOptions);
    __privateAdd(this, _root);
    __privateAdd(this, _initialized);
    __privateAdd(this, _offset);
    __privateAdd(this, _onUpdate);
    __privateSet(this, _initialized, false);
    this.onShow = () => {
    };
    this.onHide = () => {
    };
    __privateSet(this, _onUpdate, (view, prevState) => {
      const { state, composing } = view;
      const { selection, doc } = state;
      const { ranges } = selection;
      const from = Math.min(...ranges.map((range) => range.$from.pos));
      const to = Math.max(...ranges.map((range) => range.$to.pos));
      const isSame = prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection);
      if (!__privateGet(this, _initialized)) {
        const root = __privateGet(this, _root) ?? view.dom.parentElement ?? document.body;
        root.appendChild(this.element);
        __privateSet(this, _initialized, true);
      }
      if (composing || isSame)
        return;
      if (!__privateGet(this, _shouldShow).call(this, view, prevState)) {
        this.hide();
        return;
      }
      const virtualEl = {
        getBoundingClientRect: () => posToDOMRect(view, from, to)
      };
      computePosition(virtualEl, this.element, {
        placement: __privateGet(this, _floatingUIOptions).placement ?? "top",
        middleware: [flip(), offset(__privateGet(this, _offset)), shift(), ...__privateGet(this, _middleware)]
      }).then(({ x, y }) => {
        Object.assign(this.element.style, {
          left: `${x}px`,
          top: `${y}px`
        });
      });
      this.show();
    });
    this.update = (view, prevState) => {
      const updater = (0, import_lodash.default)(__privateGet(this, _onUpdate), __privateGet(this, _debounce));
      updater(view, prevState);
    };
    this.destroy = () => {
    };
    this.show = (virtualElement) => {
      this.element.dataset.show = "true";
      if (virtualElement) {
        computePosition(virtualElement, this.element, {
          placement: "top",
          middleware: [flip(), offset(__privateGet(this, _offset))],
          ...__privateGet(this, _floatingUIOptions)
        }).then(({ x, y }) => {
          Object.assign(this.element.style, {
            left: `${x}px`,
            top: `${y}px`
          });
        });
      }
      this.onShow();
    };
    this.hide = () => {
      if (this.element.dataset.show === "false")
        return;
      this.element.dataset.show = "false";
      this.onHide();
    };
    this.element = options.content;
    __privateSet(this, _debounce, options.debounce ?? 200);
    __privateSet(this, _shouldShow, options.shouldShow ?? __privateMethod(this, _TooltipProvider_instances, _shouldShow_fn));
    __privateSet(this, _offset, options.offset);
    __privateSet(this, _middleware, options.middleware ?? []);
    __privateSet(this, _floatingUIOptions, options.floatingUIOptions ?? {});
    __privateSet(this, _root, options.root);
    this.element.dataset.show = "false";
  }
};
_debounce = /* @__PURE__ */ new WeakMap();
_shouldShow = /* @__PURE__ */ new WeakMap();
_middleware = /* @__PURE__ */ new WeakMap();
_floatingUIOptions = /* @__PURE__ */ new WeakMap();
_root = /* @__PURE__ */ new WeakMap();
_initialized = /* @__PURE__ */ new WeakMap();
_offset = /* @__PURE__ */ new WeakMap();
_onUpdate = /* @__PURE__ */ new WeakMap();
_TooltipProvider_instances = /* @__PURE__ */ new WeakSet();
_shouldShow_fn = function(view) {
  const { doc, selection } = view.state;
  const { empty, from, to } = selection;
  const isEmptyTextBlock = !doc.textBetween(from, to).length && view.state.selection instanceof TextSelection;
  const isTooltipChildren = this.element.contains(document.activeElement);
  const notHasFocus = !view.hasFocus() && !isTooltipChildren;
  const isReadonly = !view.editable;
  if (notHasFocus || empty || isEmptyTextBlock || isReadonly)
    return false;
  return true;
};
function tooltipFactory(id) {
  const tooltipSpec = $ctx(
    {},
    `${id}_TOOLTIP_SPEC`
  );
  const tooltipPlugin = $prose((ctx) => {
    const spec = ctx.get(tooltipSpec.key);
    return new Plugin({
      key: new PluginKey(`${id}_TOOLTIP`),
      ...spec
    });
  });
  const result = [tooltipSpec, tooltipPlugin];
  result.key = tooltipSpec.key;
  result.pluginKey = tooltipPlugin.key;
  tooltipSpec.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Ctx<tooltipSpec>|${id}`
  };
  tooltipPlugin.meta = {
    package: "@milkdown/plugin-tooltip",
    displayName: `Prose<tooltip>|${id}`
  };
  return result;
}

export {
  TooltipProvider,
  tooltipFactory
};
//# sourceMappingURL=chunk-ITBF6OGV.js.map
